package chipyard.fpga.u55c

import chisel3._
import org.chipsalliance.cde.config._
import org.chipsalliance.diplomacy._
import org.chipsalliance.diplomacy.lazymodule._
import org.chipsalliance.diplomacy.bundlebridge.BundleBridgeSource
import sifive.fpgashells.shell._
import sifive.fpgashells.shell.xilinx._
import sifive.fpgashells.ip.xilinx._
import freechips.rocketchip.prci._
import freechips.rocketchip.amba.axi4._


case class CustomXDMADesignInput(wrangler: ClockAdapterNode, masterClockNode: FixedClockBroadcastNode)(implicit val p: Parameters)

case class CustomXDMAOverlayOutput(master: AXI4OutwardNode, masterLite: AXI4OutwardNode, config: CustomXDMAParams)

trait CustomXDMAShellPlacer[Shell] extends ShellPlacer[CustomXDMADesignInput, PCIeShellInput, CustomXDMAOverlayOutput]

case object CustomXDMAOverlayKey extends Field[Seq[DesignPlacer[CustomXDMADesignInput, PCIeShellInput, CustomXDMAOverlayOutput]]](Nil)

abstract class CustomXDMAPlacedOverlay[IO <: Data]
(
  val name: String, val di: CustomXDMADesignInput, val si: PCIeShellInput
) extends IOPlacedOverlay[IO, CustomXDMADesignInput, PCIeShellInput, CustomXDMAOverlayOutput] {
  implicit val p = di.p
}

abstract class PCIeCustomXDMAPlacedOverlay(
  val shell: U55CShellBasicOverlays, name: String,
  val designInput: CustomXDMADesignInput, val shellInput: PCIeShellInput, config: CustomXDMAParams
) extends CustomXDMAPlacedOverlay[XDMATopPads](name, designInput, shellInput) {

  val pcie = LazyModule(new CustomXDMA(config))
  val masterClockConverter = LazyModule(new LazyAXI4ClockConverter("xdma_master", isAXILite = false))
  val masterLiteClockConverter = LazyModule(new LazyAXI4ClockConverter("xdma_master_lite", isAXILite = true))
  val bridge = BundleBridgeSource(() => new XDMABridge(config.lanes))
  val topBridge = shell {
    bridge.makeSink()
  }
  // AXI clock generated by XDMA
  val axiClk = ClockSourceNode(freqMHz = config.axiMHz)
  // AXI clock after going through reset wrangler
  val axiClkFixedNode = FixedClockBroadcast()

  axiClkFixedNode := designInput.wrangler := axiClk

  masterClockConverter.node := pcie.master
  masterLiteClockConverter.node := pcie.masterLite

  // input clock node
  masterClockConverter.slaveClockNode := axiClkFixedNode
  masterLiteClockConverter.slaveClockNode := axiClkFixedNode
  // output master clock
  masterClockConverter.masterClockNode := designInput.masterClockNode
  masterLiteClockConverter.masterClockNode := designInput.masterClockNode

  val master: AXI4OutwardNode = masterClockConverter.node
  val masterLite: AXI4OutwardNode = masterLiteClockConverter.node

  def overlayOutput = CustomXDMAOverlayOutput(
    master,
    masterLite,
    pcie.c
  )

  def ioFactory = new XDMATopPads(config.lanes)

  InModuleBody {
    val (axi, _) = axiClk.out.head
    val b = bridge.out.head._1

    b.lanes <> pcie.module.io.pads

    axi.clock := pcie.module.io.clocks.axi_aclk
    axi.reset := !pcie.module.io.clocks.axi_aresetn
    pcie.module.io.clocks.sys_rst_n := b.srstn
    pcie.module.io.clocks.sys_clk := b.ODIV2
    pcie.module.io.clocks.sys_clk_gt := b.O

    shell.sdc.addGroup(clocks = Seq(s"${name}_ref_clk"), pins = Seq(pcie.module.blackbox.io.axi_aclk))
    shell.sdc.addAsyncPath(Seq(pcie.module.blackbox.io.axi_aresetn))
  }

  shell {
    // pass signals from top level shell to the overlay
    InModuleBody {
      val b = topBridge.in.head._1

      val ibufds = Module(new IBUFDS_GTE4)
      ibufds.suggestName(s"${name}_refclk_ibufds")
      ibufds.io.CEB := false.B
      ibufds.io.I := io.refclk.p
      ibufds.io.IB := io.refclk.n
      b.O := ibufds.io.O
      b.ODIV2 := ibufds.io.ODIV2
      b.srstn := shell.pcie_rst_n
      io.lanes <> b.lanes

      shell.sdc.addClock(s"${name}_ref_clk", io.refclk.p, 100)
    }
  }
}

class U55CPCIeCustomXDMAPlacedOverlay(
  shell: U55CShellBasicOverlays, name: String,
  designInput: CustomXDMADesignInput, shellInput: PCIeShellInput, config: CustomXDMAParams
) extends PCIeCustomXDMAPlacedOverlay(
  shell, name, designInput, shellInput, config
) {
  shell { InModuleBody {
    val ref = Seq("AL15", "AL14")
    // Bank 226 + 227
    val rxp = Seq("AL2", "AM4", "AN6", "AN2", "AP4", "AR2", "AT4", "AU2") // [0-7]
    val rxn = Seq("AL1", "AM3", "AN5", "AN1", "AP3", "AR1", "AT3", "AU1") // [0-7]
    val txp = Seq("AL11", "AM9", "AN11", "AP9", "AR11", "AR7", "AT9", "AU11") // [0-7]
    val txn = Seq("AL10", "AM8", "AN10", "AP8", "AR10", "AR6", "AT8", "AU10") // [0-7]

    def bind(io: Seq[IOPin], pad: Seq[String]) {
      (io zip pad) foreach { case (io, pad) => shell.xdc.addPackagePin(io, pad) }
    }
    bind(IOPin.of(io.refclk), ref)
    // We do these individually so that zip falls off the end of the lanes:
    bind(IOPin.of(io.lanes.pci_exp_txp), txp)
    bind(IOPin.of(io.lanes.pci_exp_txn), txn)
    bind(IOPin.of(io.lanes.pci_exp_rxp), rxp)
    bind(IOPin.of(io.lanes.pci_exp_rxn), rxn)
  }}
}

class U55CPCIeCustomXDMAShellPlacer(shell: U55CShellBasicOverlays, val shellInput: PCIeShellInput)(implicit val valName: ValName)
  extends CustomXDMAShellPlacer[U55CShellBasicOverlays] {
  val config = CustomXDMAParams(
    name = "u55c_xdma",
    location = "PCIE4C_X1Y0",
    lanes = 8
  )
  def place(designInput: CustomXDMADesignInput) = new U55CPCIeCustomXDMAPlacedOverlay(
    shell, valName.value, designInput, shellInput, config
  )
}